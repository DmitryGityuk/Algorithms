package sort;

import java.util.Arrays;

import static java.lang.System.out;

/**
 * Описание алгоритма:
 * 1. Создаем результирующую последовательность длинна которой равна длине базовой.
 * Создаем две вспомогательных переменных для хранения индексов (l и r) присваиваем им значение индексов первого элемента
 * в первой подпоследовательности и первого элемента во второй подпоследовательности соответственно.
 * 2. Выполняем проход по результирующей последовательности от l до конца второй подпоследовательности.
 * Для добавления элемента в результирующую последовательность выполняем ряд проверок:
 * 2.1 Если значение индекса l больше длинны первой подпоследовательности то добавляем элемент стоящий на индексе r во второй подпоследовательности. r++.
 * 2.2 Если значение индекса r больше длинны второй подпоследовательности то добавляем элемент стоящий на индексе l в первой подпоследовательности. l++.
 * 2.3 Если элемент на индексе l меньше элемента на индексе r то добавить элемент стоящий на индексе l в первой подпоследовательности. l++.
 * 2.4 Добавляем элемент стоящий на индексе r во второй подпоследовательности. r++.
 */
public class MergeSortedSubsequences {
    public static void main(String[] args) {
        int[] array = new int[]{1, 3, 9, 11, 2, 5, 8, 17};
        out.println(Arrays.toString(array));
        merge(array, 0, 3, 4, 7);
        out.println(Arrays.toString(array));
    }

    public static void merge(int[] array, int ls, int le, int rs, int re) {
        int[] result = Arrays.copyOf(array, array.length);
        int l = ls;
        int r = rs;
        for (int i = ls; i <= re; i++) {
            if (l > le) {
                array[i] = result[r];
                r++;
            } else if (r > re) {
                array[i] = result[l];
                l++;
            } else if (result[l] < result[r]) {
                array[i] = result[l];
                l++;
            } else {
                array[i] = result[r];
                r++;
            }
        }
    }
}
